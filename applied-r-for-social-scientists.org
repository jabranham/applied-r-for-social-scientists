#+TITLE:     Applied R for Social Scientists
#+AUTHOR:    J. Alexander Branham
#+EMAIL:     branham@utexas.edu
#+DATE:      Spring 2016
#+startup: beamer
#+LaTeX_CLASS: beamer
#+LATEX_CMD: xelatex
#+OPTIONS: toc:nil H:2
#+LATEX_CLASS_OPTIONS: [colorlinks, urlcolor=blue, aspectratio=169]
#+BEAMER_THEME: metropolis[titleformat=smallcaps, progressbar=frametitle] 
#+PROPERTY: session *R-session* 
#+PROPERTY: results output 
#+PROPERTY: exports both
#+PROPERTY: cache yes
#+PROPERTY: tangle "./R-for-social-scientists.R"

* This class
** This class
- Assumption of /some/ previous exposure to R
  - We're not explaining assignment, packages, calling functions, etc
- Will /not/ be covering statistics
- Alex will start with some common data tasks: loading, variable
  creation, merging, etc
- Daniel will take the second part to talk about tables and
  visualization 

* Getting the data
** Download the data
- =source()= runs a file through R
- This one checks if you have the data already and tries to download
  it if not
- The dataset we're using is the General Social Survey spanning 1972-2014

#+NAME: download-data
#+BEGIN_SRC R
  source("check-gss-and-maybe-download.R")
#+END_SRC

** Reading data
- R can read almost any data
- Here are some of the most common types:

| package | function   | file formats               |
|---------+------------+----------------------------|
| foreign | =read.*=   | dta, spss, etc             |
| haven   | =read_*=   | dta (13+) files and others |
| readr   | =read_csv= | csv files                  |
  
** Read data
- We have stata data (=*.dta=)
- =convert.factors=FALSE= ensures that R doesn't convert the values to
  the labels that stata uses

#+BEGIN_SRC R
  GSS <- foreign::read.dta("./data/GSS7214_R4.DTA",
                           convert.factors = FALSE)
#+END_SRC

* Data management
** The data: a table
- Let's get a sense of the data we're working with
- Do you want more, less, or about the same spending? (education and
  social security)

#+BEGIN_SRC R
  table(GSS$nateduc, GSS$natsoc, exclude = NULL)
#+END_SRC

** correlation
- =cor= gives us (by default) the pearson's $r$ between two variables
- Without setting =use=, R tries to use the whole data, some of which
  are missing and thus results in =NA=

#+BEGIN_SRC R
  cor(GSS$nateduc,
      GSS$natsoc,
      use = "complete.obs")
#+END_SRC

** Variable creation 
- Let's make an indicator variable for whether a respondent is black
  or not
- Here's the =race= variable
- I also like to make sure that I'm not going to overwrite an existing
  variable
 

*** Race variable                                                     :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:
#+BEGIN_SRC R
  table(GSS$race)
#+END_SRC

*** Does black exist already?                                         :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:
#+BEGIN_SRC R
  table(GSS$black)
#+END_SRC

** Variable creation
- Using =ifelse= to create a variable conditional on other var's
  values

#+BEGIN_SRC R
  GSS$black <- ifelse(GSS$race == 2, TRUE, FALSE)
  table(GSS$black)
#+END_SRC

** Subsetting observations
- Now let's check to see if that correlation is different for black
  people
- Note how ugly this looks!

#+BEGIN_SRC R
  cor(GSS$nateduc[GSS$black == TRUE],
      GSS$natsoc[GSS$black == TRUE],
      use="complete.obs")
#+END_SRC

** dplyr
- =dplyr= is an R package that makes data management /much/ easier
- Different functions for data munging:
  - =filter()=, =select()=, =mutate()=
- It introduces the pipe operator =%>%= to the language
- Functions for merging data
  - =*_join=: full, inner, left, right
- =group_by=, which lets us perform operations on groups of the data
- Because I'll use =tidyr= later and it gets angry if you load it
  after =dplyr=, I'm loading it now

#+BEGIN_SRC R
  library(tidyr)
  suppressPackageStartupMessages(library(dplyr))
#+END_SRC

** Subsetting the dplyr way
- The pipe (=%>%=) "pipes" the output of the last thing into the first
  argument of the next thing
- =summarize= (or =summarise=) from =dplyr= returns a =data.frame=
*** Without pipes/dplyr                                               :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:

    #+BEGIN_SRC R
      with(filter(GSS, black == TRUE),
            cor(nateduc, natsoc,
                use = "complete.obs"))
    #+END_SRC

*** With pipes/dplyr                                                  :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:

    #+BEGIN_SRC R
      GSS %>%
        filter(black == TRUE) %>%
        summarize(mycor =
            cor(nateduc, natsoc,
            use = "complete.obs"))
    #+END_SRC

** Dropping observations
- 1972 doesn't have any observations we're interested in (our spending
  variables weren't asked), so let's drop it
- Again, we can use =filter=, but this time we assign the result back
  to =GSS=:


#+BEGIN_SRC R
  GSS <- GSS %>%
    filter(year != 1972)
#+END_SRC

** Factors
- Variables with categories can be represented as factors in R
- If you want R to think they're ordered, you can use =ordered = TRUE=
  as an argument

# GSS$sex <- factor(GSS$sex,
#                   levels=c(1, 2),
#                   labels=c("M", "F"))

*** Makes sex a factor                                                :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.3
    :END:
#+BEGIN_SRC R
  table(GSS$sex)
#+END_SRC

*** Makes a table                                                     :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.7
    :END:

    #+BEGIN_SRC R
      GSS <- GSS %>%
        mutate(sex = factor(sex,
                            levels = c(1, 2),
                            labels = c("M", "F")))

      table(GSS$sex)
    #+END_SRC

** Operations by subcategories
- =dplyr= provides =group_by=
- Lets us perform operations to grouped data


#+BEGIN_SRC R
  thecors <- GSS %>%
    group_by(sex, black) %>%
    summarize(thecor = cor(nateduc, natsoc,
                         use = "complete.obs"),
              n = n())
#+END_SRC

** Operations by subcategories

#+BEGIN_SRC R
  print(thecors)
#+END_SRC

** Aggregation 
- Maybe we're interested in preferences by year?


#+BEGIN_SRC R
  gss_yearly <- GSS %>%
    group_by(year) %>%
    summarize(educ = mean(nateduc,
                          na.rm = TRUE),
              soc = mean(natsoc,
                         na.rm = TRUE))
#+END_SRC

** Aggregation

   #+BEGIN_SRC R
     head(gss_yearly)
   #+END_SRC

** Functions
- Means are nice, but there are other ways to summarize data
- What if we want to look at the proportion of people who support more
  spending minus the proportion who support less? 


#+BEGIN_SRC R
  netsupport <- function(thedata){
    prop_more <- mean(thedata == 1, na.rm = TRUE)
    prop_less <- mean(thedata == 3, na.rm = TRUE)
    prop_more - prop_less
  }
#+END_SRC 

** Functions
#+BEGIN_SRC R
  GSS %>%
    group_by(year) %>%
    summarize(support_educ = netsupport(nateduc),
              support_soc = netsupport(natsoc))
#+END_SRC

** Merging 
- The =ggplot2= package provides the =economics= data.frame that has
  US economic data starting in July 1967
- =?economics= gives more info 

  #+BEGIN_SRC R
    library(ggplot2)
    head(economics, 3)
  #+END_SRC

** Merging
- Let's make an unemployment rate by unemploy/pop

#+BEGIN_SRC R
  economics <- economics %>%
    mutate(unemp_rate = unemploy / pop)
#+END_SRC

- Note =mutate= is from dplyr, this is base R:

#+BEGIN_SRC R
  economics$unemp_rate <- economics$unemploy / economics$pop
#+END_SRC


** Merging
- The =economics= data is monthly and our GSS data is yearly, so we
  need to aggregate 

#+BEGIN_SRC R
  economics_yearly <- economics %>%
    mutate(year = format(date, "%Y")) %>%
    group_by(year) %>%
    summarize(unemp = mean(unemp_rate))
#+END_SRC

** Merging
- Let's see what our data looks like now!

#+BEGIN_SRC R
  head(economics_yearly)
#+END_SRC

** Merging
- Now we have two data.frame objects --- =gss_yearly= and
  =economics_yearly= --- that we want to join together
- =dplyr= provides a really easy way of doing this
- The jargon comes from SQL, a programming language used to store data
- What you probably call a "merge" dplyr calls a "join"
- =*_join= where =*= is either =full=, =inner=, =left=, or =right=
- We'll use =left_join= since the economics data contains years that
  aren't in the GSS

** Merging

#+BEGIN_SRC R
  gss_yearly <- left_join(gss_yearly,
                          economics_yearly,
                          by = "year")
#+END_SRC

** Errors
- Error: cannot join on columns 'year' x 'year': Can't join on 'year'
  x 'year' because of incompatible types (character / integer)

** Errors
- The error on the last slide indicates that the =year= variable in
  the two datasets is different
- Let's verify that:

***                                                                   :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.4
    :END:
#+BEGIN_SRC R
  class(gss_yearly$year)
#+END_SRC

***                                                                   :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.6
    :END:
#+BEGIN_SRC R
  class(economics_yearly$year)
#+END_SRC


** Merging
- Solution: change =economics_yearly$year= to an integer

#+BEGIN_SRC R
  economics_yearly$year <- as.integer(economics_yearly$year)

  gss_yearly <- left_join(gss_yearly,
                          economics_yearly,
                          by="year")
#+END_SRC

** Merging 

#+BEGIN_SRC R
  head(gss_yearly)
#+END_SRC

** Writing data
- Maybe you want to save this new data so you don't have to re-run the
  merging whenever you want to 

| package | function     | result     |
|---------+--------------+------------|
| readr   | =write_csv=  | csv file   |
| utils   | =write.csv=  | csv file   |
| base    | =save=       | Rdata file |
| xlsx    | =write.xlsx= | excel file |

- R can also write to stata/SPSS/SAS files through =foreign= or =haven=

** Writing data
- Let's save a csv file
- If the =data/= subfolder doesn't exist, this will produce an error
- The script that we ran at the beginning created this if it didn't
  already exist


#+BEGIN_SRC R
  readr::write_csv(gss_yearly, "data/gss-yearly-data.csv")
#+END_SRC

* Tidying data
** What is tidy data?
- Sometimes the data you get aren't /tidy/
- Tidy data are data where each row is an observation, each column a
  variable, and each cell a value
- Most of the strategies I showed you above assume that you're dealing
  with tidy data
- Remember I loaded tidyr earlier, so there's no need to call
  =library= again

** Example of untidy data

#+BEGIN_SRC R
  messy1 <- data_frame(
    country = c("Afghanistan", "Albania", "Algeria"), 
    "2007" = c(43.82, 76.42, 72.30), 
    "2002" = c(42.13, 75.65, 70.99))
#+END_SRC

** Untidy data
#+BEGIN_SRC R
  print(messy1)
#+END_SRC

** Use gather when you have non-variable columns
- =gather= can also turn wide to long
#+BEGIN_SRC R
  gather(messy1, "year", "life_expect", 2:3)
#+END_SRC

** Untidy data

#+BEGIN_SRC R
  messy2 <- data.frame(
    country = c(rep("Afghanistan", 4), rep("Albania", 4), rep("Algeria", 4)), 
    year = c(rep(2002, 2), rep(2007, 2)), 
    variable = c("life_expect", "pop"), 
    value = c(42.12, 25268405, 43.82, 31889923,
              75.65, 3508512, 76.42, 3600523,
              70.99, 31287142, 72.30, 33333216)
  )
#+END_SRC

** Untidy data

   #+BEGIN_SRC R
     head(messy2)
   #+END_SRC

** use spread!
- =spread= can also turn long to wide
#+BEGIN_SRC R
  spread(messy2, key = variable, value)
#+END_SRC

** separate and unite
- If you have two variables in one column, use =separate=
  - For example, a rate of # of people with a trait / total population
    in each country
- One variable across two columns? use =unite=
  - one column for century (19, 20) and another for year (00... 09)

** For fun: nested date
- Some data is nested in a hierarchical way
- the =gapminder= data are a good example[fn:1]

#+BEGIN_SRC R
  library(gapminder)
  head(gapminder, 3)
  library(ggplot2)
#+END_SRC

** Life expectancy over time


#+BEGIN_SRC R :results value graphics :file gapminder-plot.pdf :exports both
  ggplot(gapminder, aes(x = year, y = lifeExp,
                        color = continent, by = country)) +
    geom_line()
#+END_SRC


** life expectancy over time
#+ATTR_LATEX: :float t :width 0.6\textwidth
[[file:gapminder-plot.pdf]]


** introducing the nest function

#+BEGIN_SRC R
  by_country <- gapminder %>%
    group_by(continent, country) %>%
    nest()
#+END_SRC

** nest
- Now we have a data frame with one row per group and a column where
  each cell is itself a whole data frame

#+BEGIN_SRC R
  head(by_country,3)
#+END_SRC

** nest
- So for example the first element of the =data= column contains the
  whole data frame for Afghanistan 

#+BEGIN_SRC R
  by_country$data[[1]]
#+END_SRC

** nest
- You can create a linear model for each country then:


#+BEGIN_SRC R
  by_country <- by_country %>%
    mutate(model = purrr::map(data, 
                              ~ lm(lifeExp ~ year, data = .)))
#+END_SRC

** nest

#+BEGIN_SRC R
  head(by_country, 3)
#+END_SRC

** nest
- Here we can extract the fitted values and plot a lint of the fitted values
- By continent, country 

#+BEGIN_SRC R :results value graphics :file gapminder-fitted-plot.pdf :exports both
  by_country %>% unnest(model %>% purrr::map(broom::augment)) %>%
    select(continent, country, year, .fitted) %>%
    ggplot(aes(x = year, y = .fitted,
               by = country, color = continent)) +
    geom_line()
#+END_SRC

** Graphing
#+ATTR_LATEX: :width 0.6\textwidth :float t
[[file:gapminder-fitted-plot.pdf]]

* Iteration: Loops and apply

** DRY
- DRY (/Don't Repeat Yourself/) is an acronym from computer science
- Repeating yourself makes your code harder to deal with:
  - Intent is less clear
  - Harder to spot bugs

** Loops
- For loops get lots of hate online because people think they're slow
  (they aren't)
- They can be hard to read, though


#+BEGIN_SRC R
  thedata <- data_frame(
    one = rnorm(100), two = rnorm(100), 
    three = rnorm(100), four = rnorm(100)
  )
#+END_SRC


** For loops

*** Medians                                                           :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:

#+BEGIN_SRC R
  output <- list()
  output[[1]] <- median(thedata$one)
  output[[2]] <- median(thedata$two)
  output[[3]] <- median(thedata$three)
  output[[4]] <- median(thedata$four)
  print(output); rm(output)
#+END_SRC

*** Medians - looping                                                 :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:

#+BEGIN_SRC R
  output <- list()
  for (i in 1:4) {
    output[[i]] <- median(thedata[[i]])
  }
  print(output); rm(output)
#+END_SRC

** Mapping functions
- Of course, we oftentimes need to perform an operation across many
  columns
- This is where the =map= family (from =purrr=) steps in:

  #+BEGIN_SRC R
    purrr::map(thedata, median)
    purrr::map_dbl(thedata, median)
  #+END_SRC




* Footnotes

[fn:1] This example taken from the [[http://blog.rstudio.org/2016/02/02/tidyr-0-4-0/][blog post introducing nest]] 
