#+TITLE:     Applied R for Social Scientists
#+AUTHOR:    J. Alexander Branham
#+EMAIL:     branham@utexas.edu
#+DATE:      Spring 2016
#+startup: beamer
#+LaTeX_CLASS: beamer
#+LATEX_CMD: xelatex
#+OPTIONS: toc:nil H:2
#+LATEX_CLASS_OPTIONS: [colorlinks, urlcolor=blue, aspectratio=169]
#+BEAMER_THEME: metropolis[titleformat=smallcaps, progressbar=frametitle] 
#+PROPERTY: session *R-session* 
#+PROPERTY: results output 
#+PROPERTY: exports both
#+PROPERTY: cache yes
#+PROPERTY: tangle "./R-for-social-scientists.R"
#+LATEX_HEADER: \usepackage{minted}

* This class
** This class
- Assumption of /some/ previous exposure to R
  - We're not explaining assignment, packages, calling functions, etc
- Will /not/ be covering statistics
- Alex will start with some common data tasks: loading, variable
  creation, merging, etc
- Daniel will take the second part to talk about tables and
  visualization 

* Getting the data
** Download the data
- =source()= runs a file through R
- This one checks if you have the data already and tries to download
  it if not
- The dataset we're using is the General Social Survey spanning 1972-2014

#+NAME: download-data
#+BEGIN_SRC R
  source("check-gss-and-maybe-download.R")
#+END_SRC

** That file

** Reading data

| package | function   | file formats   |
|---------+------------+----------------|
| foreign | =read.*=   | dta, spss, etc |
| haven   | =read_*=   | dta, spss, etc |
| utils   | =read.csv= | csv files      |
| readr   | =read_csv= | csv files      |
  
** Read data
- We have stata data (=*.dta=)
- Two packages in R: =foreign= and =haven=
- =foreign= is older but more stable
- =haven= is newer and can read Stata 13+ files
- =convert.factors=FALSE= ensures that R doesn't convert the values to
  the labels that stata uses

#+BEGIN_SRC R
  GSS <- foreign::read.dta("./data/GSS7214_R4.DTA",
                           convert.factors = FALSE)
#+END_SRC

* Data management
** The data: a table
- Let's get a sense of the data we're working with
- Do you want more, less, or about the same spending? (education and
  social security)

#+BEGIN_SRC R
  table(GSS$nateduc, GSS$natsoc, exclude = NULL)
#+END_SRC

** correlation
- =cor= gives us (by default) the pearson's $r$ between two variables
- Without setting =use=, R tries to use the whole data, some of which
  are missing and thus results in =NA=

#+BEGIN_SRC R
  cor(GSS$nateduc,
      GSS$natsoc,
      use="complete.obs")
#+END_SRC

** Variable creation 
- Let's make an indicator variable for whether a respondent is black
  or not
- Here's the =race= variable
- I also like to make sure that I'm not going to overwrite an existing
  variable
 

*** Race variable                                                     :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:
#+BEGIN_SRC R
  table(GSS$race)
#+END_SRC

*** Does black exist already?                                         :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:
#+BEGIN_SRC R
  table(GSS$black)
#+END_SRC

** Variable creation
- Using =ifelse= to create a variable conditional on other var's
  values

#+BEGIN_SRC R
  GSS$black <- with(GSS, ifelse(race == 2, TRUE, FALSE))
  table(GSS$black)
#+END_SRC

** Subsetting observations
- Now let's check to see if that correlation is different for black
  people
- Note how ugly this looks!

#+BEGIN_SRC R
  cor(GSS$nateduc[GSS$black == TRUE],
      GSS$natsoc[GSS$black == TRUE],
      use="complete.obs")
#+END_SRC

** dplyr
- =dplyr= is an R package that makes data management /much/ easier
- Different functions for data munging:
  - =filter()=, =select()=, =mutate()=
- It introduces the pipe operator =%>%= to the language
- Functions for merging data
  - =*_join=: full, inner, left, right
- =group_by=, which lets us perform operations on groups of the data

#+BEGIN_SRC R
  suppressPackageStartupMessages(library(dplyr))
#+END_SRC

** Subsetting the dplyr way
- The pipe (=%>%=) "pipes" the output of the last thing into the first
  argument of the next thing
- =summarize= (or =summarise=) from =dplyr= returns a =data.frame=
*** Without pipes/dplyr                                               :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:

    #+BEGIN_SRC R
      with(filter(GSS, black == TRUE),
            cor(nateduc, natsoc,
                use = "complete.obs"))
    #+END_SRC

*** With pipes/dplyr                                                  :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:

    #+BEGIN_SRC R
      GSS %>%
        filter(black == TRUE) %>%
        summarize(mycor =
            cor(nateduc, natsoc,
            use = "complete.obs"))
    #+END_SRC

** Dropping observations
- 1972 doesn't have any observations we're interested in (our spending
  variables weren't asked), so let's drop it
- Again, we can use =filter=, but this time we assign the result back
  to =GSS=:


#+BEGIN_SRC R
  GSS <- GSS %>%
    filter(year != 1972)
#+END_SRC

** Factors
- Variables with categories can be represented as factors in R
- If you want R to think they're ordered, you can use =ordered = TRUE=
  as an argument
# GSS$sex <- factor(GSS$sex,
#                   levels=c(1, 2),
#                   labels=c("M", "F"))

*** Makes sex a factor                                                :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.7
    :END:
#+BEGIN_SRC R
  table(GSS$sex)
  GSS <- GSS %>%
    mutate(sex = factor(sex,
                        levels = c(1,2),
                        labels = c("M","F")))
#+END_SRC

*** Makes a table                                                     :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.3
    :END:

    #+BEGIN_SRC R
      table(GSS$sex)
    #+END_SRC

** Operations by subcategories
- =dplyr= provides =group_by=
- Lets us perform operations to grouped data


#+BEGIN_SRC R
  thecors <- GSS %>%
    group_by(sex, black) %>%
    summarize(thecor = cor(nateduc, natsoc,
                         use = "complete.obs"),
              n = n())
#+END_SRC

** Operations by subcategories

#+BEGIN_SRC R
  print(thecors)
#+END_SRC

** Aggregation 
- Maybe we're interested in preferences by year?


#+BEGIN_SRC R
  gss_yearly <- GSS %>%
    group_by(year) %>%
    summarize(educ = mean(nateduc,
                          na.rm=TRUE),
              soc = mean(natsoc,
                         na.rm=TRUE))
#+END_SRC

** Aggregation

   #+BEGIN_SRC R
     head(gss_yearly)
   #+END_SRC

** Functions
- Means are nice, but there are other ways to summarize data
- What if we want to look at the proportion of people who support more
  spending minus the proportion who support less? 


#+BEGIN_SRC R
  netsupport <- function(thedata){
    prop_more <- mean(thedata == 1, na.rm = TRUE)
    prop_less <- mean(thedata == 3, na.rm = TRUE)
    prop_more - prop_less
  }
#+END_SRC 

** Functions
#+BEGIN_SRC R
  GSS %>%
    group_by(year) %>%
    summarize(support_educ=netsupport(nateduc),
              support_soc=netsupport(natsoc))
#+END_SRC

** Merging 
- The =ggplot2= package provides the =economics= data.frame that has
  US economic data starting in July 1967
- =?economics= gives more info 

  #+BEGIN_SRC R
    library(ggplot2)
    head(economics)
  #+END_SRC

** Merging
- Let's make an unemployment rate by unemploy/pop


#+BEGIN_SRC R
  economics <- economics %>%
    mutate(unemp_rate = unemploy / pop)
#+END_SRC

** Merging
- The =economics= data is monthly and our GSS data is yearly, so we
  need to aggregate 

#+BEGIN_SRC R
  economics_yearly <- economics %>%
    mutate(year = format(date, "%Y")) %>%
    group_by(year) %>%
    summarize(unemp = mean(unemp_rate))
#+END_SRC

** Merging
- Let's see what our data looks like now!

#+BEGIN_SRC R
  head(economics_yearly)
#+END_SRC

** Merging
- Now we have two data.frame objects --- =gss_yearly= and
  =economics_yearly= --- that we want to join together
- =dplyr= provides a really easy way of doing this
- The jargon comes from SQL, a programming language used to store data
- What you probably call a "merge" dplyr calls a "join"
- =*_join= where =*= is either =full=, =inner=, =left=, or =right=
- We'll use =left_join= since the economics data contains years that
  aren't in the GSS

** Merging

#+BEGIN_SRC R
  gss_yearly <- left_join(gss_yearly,
                          economics_yearly,
                          by = "year")
#+END_SRC

** Errors
- Error: cannot join on columns 'year' x 'year': Can't join on 'year'
  x 'year' because of incompatible types (character / integer)

** Errors
- The error on the last slide indicates that the =year= variable in
  the two datasets is different
- Let's verify that:

***                                                                   :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.4
    :END:
#+BEGIN_SRC R
  class(gss_yearly$year)
#+END_SRC

***                                                                   :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.6
    :END:
#+BEGIN_SRC R
  class(economics_yearly$year)
#+END_SRC


** Merging
- Solution: change =economics_yearly$year= to an integer

#+BEGIN_SRC R
  economics_yearly$year <- as.integer(economics_yearly$year)

  gss_yearly <- left_join(gss_yearly,
                          economics_yearly,
                          by="year")
#+END_SRC

** Merging 

#+BEGIN_SRC R
  head(gss_yearly)
#+END_SRC

** Writing data
- Maybe you want to save this new data so you don't have to re-run the
  merging whenever you want to 

| package | function     | result     |
|---------+--------------+------------|
| readr   | =write_csv=  | csv file   |
| utils   | =write.csv=  | csv file   |
| base    | =save=       | Rdata file |
| xlsx    | =write.xlsx= | excel file |

- R can also write to stata/SPSS/SAS files through =foreign= or =haven=

** Writing data
- Let's save a csv file
- If the =data/= subfolder doesn't exist, this will produce an error
- The script that we ran at the beginning created this if it didn't
  already exist


#+BEGIN_SRC R
  readr::write_csv(gss_yearly, "data/gss-yearly-data.csv")
#+END_SRC

